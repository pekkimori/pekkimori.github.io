---
import type { MarkdownHeading } from "astro";

import { generateToc } from "@/utils/generateToc";
import TOCHeading from "@/components/TOCHeading.astro";

interface Props {
  headings: MarkdownHeading[];
  class?: string;
  id?: string;
}

const { headings, class: className, ...props } = Astro.props;

const toc = generateToc(headings);
---

<!-- Mobile TOC Button -->
<div
  id="toc-btn-container"
  class:list={[
    "fixed end-4 bottom-24 z-50 lg:hidden",
    "translate-y-14 opacity-0 transition duration-500",
  ]}
>
  <button
    id="toc-mobile-btn"
    class="group relative flex size-14 items-center justify-center rounded-full bg-background shadow-xl"
    aria-label="Show Table of Contents"
    type="button"
  >
    <svg class="size-6 text-accent" viewBox="0 0 24 24" fill="none">
      <rect x="4" y="6" width="16" height="2" rx="1" fill="currentColor"></rect>
      <rect x="4" y="11" width="16" height="2" rx="1" fill="currentColor"
      ></rect>
      <rect x="4" y="16" width="16" height="2" rx="1" fill="currentColor"
      ></rect>
    </svg>
    <span class="sr-only text-sm group-hover:text-accent"
      >Table of Contents</span
    >
  </button>
</div>

<!-- Mobile TOC Overlay -->
<div
  id="toc-mobile-overlay"
  class="pointer-events-none fixed end-4 bottom-36 z-50 opacity-0 transition-opacity duration-300 lg:hidden"
  style="max-width: 22rem;"
>
  <div
    class="relative flex w-full flex-col rounded-2xl bg-background/90 p-4 shadow-2xl backdrop-blur-lg"
    style="max-height: 70vh; overflow-y: auto;"
  >
    <toc-heading class="w-full" {...props}>
      <h2 class="mb-4 text-center font-semibold">TABLE OF CONTENTS</h2>
      <ul class="text-card-foreground">
        {toc.map(heading => <TOCHeading heading={heading} />)}
      </ul>
    </toc-heading>
  </div>
</div>

<!-- Desktop TOC -->
<toc-heading class={className} {...props}>
  <h2 class="font-semibold">TABLE OF CONTENTS</h2>
  <ul class="text-card-foreground mt-4">
    {toc.map(heading => <TOCHeading heading={heading} />)}
  </ul>
</toc-heading>

<script>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  interface TOCLink {
    element: HTMLAnchorElement;
    progressBar: HTMLElement;
    slug: string;
  }

  interface HeadingProgress {
    inView: boolean;
    progress: number;
  }

  class TOC extends HTMLElement {
    headings: HTMLElement[] = [];
    tocLinks: TOCLink[] = [];
    headingProgress: Record<string, HeadingProgress> = {};

    constructor() {
      super();
    }

    initializeToc() {
      // Initialize the headings and tocLinks
      this.headings = Array.from(
        document.querySelectorAll(
          "#article h2, #article h3, #article h4, #article h5, #article h6"
        )
      );
      this.tocLinks = Array.from(this.querySelectorAll('a[href^="#"]')).map(
        link => ({
          element: link as HTMLAnchorElement,
          progressBar: link.previousElementSibling as HTMLElement,
          slug: (link.getAttribute("href") || "").substring(1),
        })
      );
    }

    updatePositionAndStyle = () => {
      const windowHeight = window.innerHeight;
      const articleElement = document.querySelector("#article") as HTMLElement;
      const articleTop = articleElement?.offsetTop || 0;
      const scrollTop = window.scrollY;

      this.headings.forEach((el, index) => {
        const nextHeading = this.headings[index + 1];
        const nextHeadingTop = nextHeading
          ? nextHeading.offsetTop
          : articleElement.offsetHeight + articleTop;

        // Calculate section boundaries relative to viewport
        const headingTop = el.offsetTop;
        const headingBottom = headingTop + el.offsetHeight;
        const sectionEnd = nextHeadingTop;

        // Check if section is in viewport (allows multiple sections to be active)
        const headingInViewport = headingTop <= scrollTop + windowHeight;
        const sectionStillVisible = sectionEnd > scrollTop;
        const inView = headingInViewport && sectionStillVisible;

        // Calculate progress: section is 100% when its end reaches bottom of viewport
        const sectionHeight = sectionEnd - headingTop;
        const viewportBottom = scrollTop + windowHeight;
        const progressDistance = Math.max(0, viewportBottom - headingTop);
        const progress = Math.min(
          1,
          Math.max(0, progressDistance / sectionHeight)
        );

        this.headingProgress[el.id] = {
          inView,
          progress,
        };
      });

      this.tocLinks.forEach(({ element: el, progressBar: bar, slug }, i) => {
        const { inView, progress } = this.headingProgress[slug];
        if (this.headingProgress[slug]) {
          el.classList.toggle("highlight", inView);
          el.classList.toggle("highlight-bg-translucent", inView);
          el.classList.toggle(
            "rounded-t-2xl",
            inView &&
              (i == 0 ||
                !this.headingProgress[this.tocLinks[i - 1]?.slug].inView)
          );
          el.classList.toggle(
            "rounded-b-2xl",
            inView &&
              (i == this.tocLinks.length - 1 ||
                !this.headingProgress[this.tocLinks[i + 1]?.slug].inView)
          );
          bar.classList.toggle("is-read", !inView && progress == 1);
          bar.classList.toggle("highlight-bg", inView);
          bar.style.setProperty("height", `${progress * 90}%`);
        }
      });
    };

    connectedCallback() {
      // Listen for the headings-ready event first
      const handleHeadingsReady = () => {
        this.initializeToc();
        this.setupEventListeners();
      };

      document.addEventListener("headings-ready", handleHeadingsReady, {
        once: true,
      });

      // Fallback: Wait for content to be ready
      const waitForContent = () => {
        const article = document.querySelector("#article");
        const headings = document.querySelectorAll(
          "#article h2, #article h3, #article h4, #article h5, #article h6"
        );

        if (article && headings.length > 0) {
          // Remove the event listener since we're initializing now
          document.removeEventListener("headings-ready", handleHeadingsReady);
          this.initializeToc();
          this.setupEventListeners();
        } else {
          // Try again after a short delay
          setTimeout(waitForContent, 100);
        }
      };

      // Check if content is already ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", waitForContent);
      } else {
        // Small delay to allow headings-ready event to fire first
        setTimeout(waitForContent, 50);
      }
    }

    setupEventListeners() {
      // Smooth scroll
      this.tocLinks.forEach(link => {
        link.element.addEventListener("click", e => {
          e.preventDefault();
          const directHeading = this.headings.find(
            heading => heading.id === link.slug
          );
          if (directHeading) {
            // Temporarily disable CSS smooth scrolling to avoid conflicts
            document.documentElement.style.scrollBehavior = "auto";

            directHeading.scrollIntoView({ behavior: "smooth" });

            // Update URL after scroll starts
            setTimeout(() => {
              history.pushState(
                null,
                directHeading.textContent || "",
                link.element.getAttribute("href")
              );
              // Re-enable CSS smooth scrolling
              document.documentElement.style.scrollBehavior = "";
            }, 50);
          } else {
            console.warn(`No heading found for slug: ${link.slug}`);
          }
        });
      });

      // Initial call and listen to scroll event
      this.updatePositionAndStyle();

      // Use requestAnimationFrame for better performance
      let ticking = false;
      const scrollHandler = () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            this.updatePositionAndStyle();
            ticking = false;
          });
          ticking = true;
        }
      };

      window.addEventListener("scroll", scrollHandler);
      window.addEventListener("resize", scrollHandler);
    }
  }

  customElements.define("toc-heading", TOC);

  // Mobile TOC toggle logic
  const btn = document.getElementById("toc-mobile-btn");
  const overlay = document.getElementById("toc-mobile-overlay");
  const tocBtnContainer = document.getElementById("toc-btn-container");

  let tocOpen = false;

  function toggleTOC() {
    tocOpen = !tocOpen;
    if (tocOpen) {
      overlay?.classList.add("opacity-100");
      overlay?.classList.remove("opacity-0", "pointer-events-none");
      overlay?.classList.add("pointer-events-auto");
      document.body.style.overflow = "hidden";
    } else {
      overlay?.classList.remove("opacity-100", "pointer-events-auto");
      overlay?.classList.add("opacity-0", "pointer-events-none");
      document.body.style.overflow = "";
    }
  }

  btn?.addEventListener("click", toggleTOC);

  // Hide overlay if user clicks outside the modal
  overlay?.addEventListener("click", e => {
    if (e.target === overlay) toggleTOC();
  });

  // Sync TOC button visibility/animation with Back to Top button
  function handleTocBtnScroll() {
    const rootElement = document.documentElement;
    const scrollTotal = rootElement.scrollHeight - rootElement.clientHeight;
    const scrollTop = rootElement.scrollTop;
    const isVisible = scrollTop / scrollTotal > 0.1;

    if (tocBtnContainer) {
      if (isVisible) {
        // Add a delay before showing the TOC button
        setTimeout(() => {
          tocBtnContainer.classList.add("opacity-100");
          tocBtnContainer.classList.add("translate-y-0");
          tocBtnContainer.classList.remove("opacity-0");
          tocBtnContainer.classList.remove("translate-y-14");
        }, 200); // 200ms delay
      } else {
        // Hide immediately
        tocBtnContainer.classList.remove("opacity-100");
        tocBtnContainer.classList.remove("translate-y-0");
        tocBtnContainer.classList.add("opacity-0");
        tocBtnContainer.classList.add("translate-y-14");
        // Also hide the overlay if open, with a 200ms delay
        if (overlay?.classList.contains("opacity-100")) {
          setTimeout(() => {
            overlay.classList.remove("opacity-100", "pointer-events-auto");
            overlay.classList.add("opacity-0", "pointer-events-none");
            document.body.style.overflow = "";
            tocOpen = false;
          }, 200);
        }
      }
    }
  }

  let tocBtnTicking = false;
  document.addEventListener("scroll", () => {
    if (!tocBtnTicking) {
      window.requestAnimationFrame(() => {
        handleTocBtnScroll();
        tocBtnTicking = false;
      });
      tocBtnTicking = true;
    }
  });

  // Initial state
  handleTocBtnScroll();
</script>

<style>
  toc-heading :global(.toc-item) {
    display: flow-root;
  }
</style>
